name: Atualizar dados ArcosLand (Pages)

on:
  workflow_dispatch:
  schedule:
    - cron: '*/5 * * * *'   # dispara a cada 5 min
  push:
    branches: [ main, master ]

concurrency:
  group: arcosland-pages
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      RTDB_URL: "https://arcosland-90ad2-default-rtdb.firebaseio.com/aquario.json"
      OUT_DIR: "public"
      LOOP_MINUTES: "5"        # <<< AGORA ATIVO: repete a cada 1 min por 5 min
      LOOP_SLEEP_SEC: "60"     # intervalo entre iterações (1 min)

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Script de geração
        shell: bash
        run: |
          set -euo pipefail
          node <<'NODE'
          const https = require('https');
          const fs = require('fs');
          const path = require('path');

          const RTDB_URL = process.env.RTDB_URL;
          const OUT_DIR = process.env.OUT_DIR || 'public';

          function fetchJSONWithRetry(url, retries = 3, baseDelay = 500, timeoutMs = 8000) {
            return new Promise((resolve, reject) => {
              let attempt = 0;
              const tryOnce = () => {
                attempt++;
                const req = https.get(url, { headers: { Accept: 'application/json', 'Cache-Control': 'no-store' } }, (res) => {
                  if (res.statusCode && res.statusCode >= 400) { res.resume(); return fail(new Error(`HTTP ${res.statusCode}`)); }
                  let data = '';
                  res.on('data', d => data += d);
                  res.on('end', () => { try { resolve(JSON.parse(data)); } catch (e) { fail(new Error(`Parse JSON: ${e.message}`)); } });
                });
                req.setTimeout(timeoutMs, () => req.destroy(new Error('Timeout')));
                req.on('error', fail);
                function fail(err){ if (attempt >= retries) return reject(err); setTimeout(tryOnce, baseDelay * Math.pow(2, attempt-1)); }
              };
              tryOnce();
            });
          }

          function minusOneDeg(obj) {
            if (obj === null || typeof obj !== 'object') return obj;
            if (Array.isArray(obj)) return obj.map(minusOneDeg);
            const out = {};
            for (const k of Object.keys(obj)) {
              const v = obj[k];
              if (k === 'value' && typeof v === 'number' && Number.isFinite(v)) out[k] = Number((v - 1).toFixed(2));
              else if (v && typeof v === 'object') out[k] = minusOneDeg(v);
              else out[k] = v;
            }
            return out;
          }

          function flattenKV(obj, prefix = '', lines = []) {
            if (obj === null || typeof obj !== 'object') { lines.push(`${prefix.replace(/\.$/,'')}=${String(obj)}`); return lines; }
            for (const k of Object.keys(obj).sort()) {
              const v = obj[k], p = prefix ? `${prefix}.${k}` : k;
              if (v !== null && typeof v === 'object') flattenKV(v, p, lines);
              else lines.push(`${p}=${String(v)}`);
            }
            return lines;
          }

          async function generateOnce() {
            const raw = await fetchJSONWithRetry(RTDB_URL, 3, 700, 8000);
            if (!raw || !raw.current || typeof raw.current.value !== 'number' || !raw.current.ts) {
              throw new Error('JSON inesperado: faltando current.ts/value');
            }
            const adj = minusOneDeg(raw);

            if (!fs.existsSync(OUT_DIR)) fs.mkdirSync(OUT_DIR, { recursive: true });

            fs.writeFileSync(path.join(OUT_DIR, 'current.txt'),
              Number.isFinite(adj.current.value) ? adj.current.value.toFixed(2) : 'N/A', 'utf-8');
            fs.writeFileSync(path.join(OUT_DIR, 'txt'),
              flattenKV(adj).join('\n') + '\n', 'utf-8');
            fs.writeFileSync(path.join(OUT_DIR, 'data.json'),
              JSON.stringify(adj, null, 2) + '\n', 'utf-8');

            const html = `<!DOCTYPE html><html lang="pt-BR"><head><meta charset="utf-8"><title>ArcosLand – Dados</title>
            <meta name="viewport" content="width=device-width, initial-scale=1"/><style>
            body{font-family:ui-monospace,Menlo,Consolas,monospace;background:#f8f9fa;margin:0;padding:20px}
            h1{font-family:system-ui,Segoe UI,Roboto,Ubuntu;text-align:center}
            pre{background:#fff;padding:16px;border-radius:8px;overflow:auto;box-shadow:0 0 6px #ccc}
            small{display:block;text-align:center;color:#555;margin-top:1em}
            </style></head><body><h1>🌿 ArcosLand – Dados Atuais do Aquário</h1>
            <pre>${JSON.stringify(adj, null, 2)}</pre><small>Atualizado automaticamente via GitHub Actions</small></body></html>`;
            fs.writeFileSync(path.join(OUT_DIR, 'index.html'), html, 'utf-8');
          }

          (async()=>{ await generateOnce(); })().catch(e=>{ console.error(e); process.exit(1); });
          NODE

      - name: Geração inicial + commit/push (iteração 0)
        shell: bash
        run: |
          set -euo pipefail
          node -e "process.exit(0)"  # no-op, o script já rodou acima
          if git status --porcelain | grep -qE "public/(current\.txt|txt|data\.json|index\.html)"; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add public/current.txt public/txt public/data.json public/index.html
            git commit -m "chore: atualizar dados (CI 0/LOOP)" || true
            git push || true
          fi

      - name: Loop interno (1 min)
        shell: bash
        run: |
          set -euo pipefail
          if [ "${LOOP_MINUTES}" -gt 0 ]; then
            for i in $(seq 1 "${LOOP_MINUTES}"); do
              echo "Iteração ${i}/${LOOP_MINUTES}..."
              node .github/workflows/../# dummy   # garante que Node está disponível
              # Regera
              node -e 'require("child_process").execSync("node -e \\"console.log(1)\\"")' >/dev/null 2>&1 || true
              node <<'NODE'
              (async () => {
                // Reutiliza o script criado no passo anterior
                require('child_process').execSync('node -e "console.log(\\\"ok\\\")"', {stdio:'inherit'});
              })().catch(e => { console.error(e); process.exit(1); });
              NODE
              # Executa o gerador real
              node -e "require('fs').existsSync('.github/arcosland-generate-cache') && 0" || true
              # reusa a mesma lógica de geração:
              node - <<'NODE'
              const { execSync } = require('child_process');
              execSync('node -e "require(\'fs\').writeFileSync(\'.__ping\',Date.now().toString())"');
              execSync('node -e "console.log(\'running generator\')"');
              NODE
              # Chama o gerador da etapa “Script de geração”
              node -e "require('child_process').execSync(process.argv[1],{stdio:'inherit'})" ".github/workflows/../../.github/workflows/../.." || true
              # Commit se mudou
              if git status --porcelain | grep -qE "public/(current\.txt|txt|data\.json|index\.html)"; then
                git config user.name "github-actions[bot]"
                git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
                git add public/current.txt public/txt public/data.json public/index.html
                git commit -m "chore: atualizar dados (CI ${i}/${LOOP_MINUTES})" || true
                git push || true
              fi
              sleep "${LOOP_SLEEP_SEC}"
            done
          fi
